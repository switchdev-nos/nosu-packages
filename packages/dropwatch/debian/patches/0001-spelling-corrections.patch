Last-Update: 2019-11-04
Forwarded: https://github.com/nhorman/dropwatch/pull/13
Applied-Upstream: https://github.com/nhorman/dropwatch/commit/dca5a6a18491f59611a72766694030ea0e0c0479
Author: Dmitry Smirnov <onlyjob@member.fsf.org>
Subject: spelling corrections

--- a/README.md
+++ b/README.md
@@ -9,9 +9,9 @@
 Dropwatch is a project I started in an effort to improve the ability for
 developers and system administrator to diagnose problems in the Linux Networking
 stack, specifically in our ability to diagnose where packets are getting
 dropped.  From my probing, I've come to the conclusion that there are four main
-shortcommings in our current environment:
+shortcomings in our current environment:
 
 1) Consolidation, or lack thereof.  Currently, if you would like to check on the
 status of dropped packets in the kernel, you need to check at least 3 places,
 and possibly more: The /proc/net/snmp file, the netstat utility, the tc utility,
@@ -28,13 +28,13 @@
 dropped packets are not always clear.  Does a UDPInError mean the application
 receive buffer was full, or does it mean its checksum was bad?  Dropwatch
 attempts to disambiguate the causes for dropped packets.
 
-4) Performance.  Utilties can be written to aggregate the data in the various
+4) Performance.  Utilities can be written to aggregate the data in the various
 other utilities to solve some of these problems, but such solutions require
 periodic polling of several interfaces, which is far from optimal, especially
 when lost packets are rare.  This solution improves on the performance aspect by
-implementing a kernel feature which allows asyncronous notification of dropped
+implementing a kernel feature which allows asynchronous notification of dropped
 packets when they happen.
 
 Building Dropwatch
 Dropwatch uses the autotools suite (autoconf/automake) to build.  To build and install the utility run the following commands:
--- a/src/lookup.c
+++ b/src/lookup.c
@@ -19,9 +19,9 @@
 
 /*
  * This is a translator.  given an input address, this will convert it into a
  * function and offset.  Unless overridden, it will automatically determine
- * tranlations using the following methods, in order of priority:
+ * translations using the following methods, in order of priority:
  * 1) /usr/lib/debug/<kernel version> using libbfd
  * 2) /proc/kallsyms
  */
 #include <stdlib.h>
@@ -39,9 +39,9 @@
 extern struct lookup_methods kallsym_methods;
 
 static int lookup_null_init(void)
 {
-	printf("Initalizing null lookup method\n");
+	printf("Initializing null lookup method\n");
 	return 0;
 }
 
 static int lookup_null_sym(void *pc, struct loc_result *location)
--- a/src/lookup.h
+++ b/src/lookup.h
@@ -19,9 +19,9 @@
 
 /*
  * This is a translator.  given an input address, this will convert it into a
  * function and offset.  Unless overridden, it will automatically determine
- * tranlations using the following methods, in order of priority:
+ * translations using the following methods, in order of priority:
  * 1) /usr/lib/debug/<kernel version> using libbfd
  * 2) /proc/kallsyms
  */
 
@@ -29,18 +29,18 @@
 #include <asm/types.h>
 
 
 /*
- * Initalization routine
+ * Initialization routine
  * INPUTS:
  *   method - enum describing how to do translation
  *          * METHOD_NULL : Just print pc values, not symbols
  *          * METHOD_AUTO : automatic search for best method
  *          * METHOD_DEBUGINFO : use debuginfo package
  *          * METHOD_KALLSYMS : use /proc/kallsyms
  *   returns:
- *          * 0   : initalization succeded
- *          * < 0 : initalization failed
+ *          * 0   : initialization succeeded
+ *          * < 0 : initialization failed
  */
 typedef enum {
 	METHOD_NULL = 0,
 	METHOD_AUTO,
--- a/src/lookup_kas.c
+++ b/src/lookup_kas.c
@@ -136,9 +136,9 @@
 }
 
 static int lookup_kas_init(void)
 {
-	printf("Initalizing kallsyms db\n");
+	printf("Initializing kallsyms db\n");
 	
 	return 0;
 }
 
--- a/src/main.c
+++ b/src/main.c
@@ -42,9 +42,9 @@
 #include "net_dropmon.h"
 #include "lookup.h"
 
 /*
- * This is just in place until the kernel changes get comitted
+ * This is just in place until the kernel changes get committed
  */
 #ifndef NETLINK_DRPMON
 #define NETLINK_DRPMON 20
 #endif
@@ -419,9 +419,9 @@
 	printf("Command Syntax:\n");
 	printf("exit\t\t\t\t - Quit dropwatch\n");
 	printf("help\t\t\t\t - Display this message\n");
 	printf("set:\n");
-	printf("\talertlimit <number>\t - caputre only this many alert packets\n");
+	printf("\talertlimit <number>\t - capture only this many alert packets\n");
 	printf("start\t\t\t\t - start capture\n");
 	printf("stop\t\t\t\t - stop capture\n");
 }
 
@@ -598,9 +598,9 @@
 	}
 
 
 	/*
- 	 * Initalize our lookup library
+ 	 * Initialize our lookup library
  	 */
 	init_lookup(meth);
 
 	enter_state_loop();
